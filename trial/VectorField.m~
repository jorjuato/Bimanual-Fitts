classdef VectorField < handle
   properties(SetAccess = private)
      pc
      xo
      neighbourhood=[3,3]
      binnumber=51
      fs = 1E3
      step=5
      minValsToComputeCondProb=11
      hand=''
      use_norm
      unimanual=false
   end % properties
   
   properties (Dependent = true, SetAccess = private)
      vectors
      angles
   end
   
   methods
      %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
      %Properties getters and setter
      %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
      function vectors = get.vectors(obj)
        %Get Kramers-Moyal coefficients
        [vectors, xo, ~]=KMcoef_2D(obj.xo,obj.pc,1/obj.fs,[1,2]);
        vectors{end+1} = xo;      
      end
      
      function angles = get.angles(obj)    
        absAngles = atan2(obj.vectors{1},obj.vectors{2});
        angDiff = obj.eval_neighbours(absAngles, obj.neighbourhood, @get_maxAngle);
        angles = {absAngles, angDiff};
        end % angles Property
    
      %Constructor
        function obj = VectorField(DS)%dim,binnumber,hand,use_norm)
            %if nargin<5, use_norm=true; end
            %if nargin<4, hand=''; end
            
            %Check what data is exactly, depending on the input class,
            %behave accordinly (either a Trial instance or a Cell Array)
            %Use varargin to avoid complications with parameters
            disp('Wait while computing conditional probabilites...')
            if isa(DS,'Trial')
                obj.get_trial_vf(DS.ts);
            elseif isa(DS,'Block')
                obj.get_replications_vf(obj,DS);
            else
                disp('WTFF!!')
            end
        end
        
        function get_trial_vf(obj,ts)
            if obj.use_norm == false
                %Compute bin centers
                Xo = obj.get_bincenters(ts,dim);
                %Compute input vector Y = [x,v]
                if isa(ts,'TimeSeriesUnimanual')
                    Y = [ts.x,ts.v];
                elseif strcmp(obj.hand,'L')
                    Y = [ts.Lx,ts.Lv];
                elseif strcmp(obj.hand,'R') 
                    Y = [ts.Rx,ts.Rv];
                else
                    return
                end
            else
               %Compute bin centers
               Xo = obj.get_bincenters_normalized();
               %Compute input vector Y = [x,v]
                if isa(ts,'TimeSeriesUnimanual')
                    Y = [ts.xnorm,ts.vnorm];
                elseif strcmp(obj.hand,'L')
                    Y = [ts.Lxnorm,ts.Lvnorm];
                elseif strcmp(obj.hand,'R')
                    Y = [ts.Rxnorm,ts.Rvnorm];
                else
                    return
                end
            end
            [~, obj.xo, obj.pc]=prob_2D(Y,Xo,obj.step,obj.minValsToComputeCondProb);        
        end
        
        function get_replications_vf(obj,DS,varargin)
            %Prepare matrices to store PCs
            rep=size(DS,length(dim)+1)-1;
            obj.pc = zeros(0);
            
            %Compute bin centers
            if obj.use_norm == false
                Xo = get_bincenters(DS,dim);
            else
                Xo = get_bincenters_normalized();
            end
            %Other methods
            %Xo = meshgrid(linspace(-1,1,binnumber)',linspace(-1,1,binnumber)');
            %Xo= binnumber;    
           
            %Sum conditional probability matrices of each replications
            for r=1:rep
                %Compute input vector Y = [x,v]
                if obj.use_norm == false
                    if length(dim)==1 && ~isempty(DS{dim,r})
                        Y = [DS{dim,r}.x,DS{dim,r}.v];
                    elseif strcmp(obj.hand,'L') && ~isempty(DS{dim(1),dim(2),r})
                        Y = [DS{dim(1),dim(2),r}.Lx,DS{dim(1),dim(2),r}.Lv];
                    elseif strcmp(obj.hand,'R') && ~isempty(DS{dim(1),dim(2),r})
                        Y = [DS{dim(1),dim(2),r}.Rx,DS{dim(1),dim(2),r}.Rv];
                    else
                        continue
                    end
                else
                    if length(dim)==1 && ~isempty(DS{dim,r})
                        Y = [DS{dim,r}.xnorm,DS{dim,r}.vnorm];
                    elseif strcmp(obj.hand,'L') && ~isempty(DS{dim(1),dim(2),r})
                        Y = [DS{dim(1),dim(2),r}.Lxnorm,DS{dim(1),dim(2),r}.Lvnorm];
                    elseif strcmp(obj.hand,'R') && ~isempty(DS{dim(1),dim(2),r})
                        Y = [DS{dim(1),dim(2),r}.Rxnorm,DS{dim(1),dim(2),r}.Rvnorm];
                    else
                        continue
                    end
                end
                %display(sprintf('Computing replication %d',r));
                [~, xo, pctmp]=prob_2D(Y,Xo,obj.step,obj.minValsToComputeCondProb);
                if isempty(obj.pc)
                    obj.pc = pctmp;
                else
                    obj.pc = obj.pc + pctmp;
                end
            end
            % Promediate PC
            obj.pc = obj.pc/rep;
            obj.xo = xo;
        end %get_replications_vf

        function xo = get_bincenters_normalized(obj)
            %Normalized version
            if length(obj.binnumber) == 1
                xo = {linspace(-1,1,obj.binnumber)'...
                      linspace(-1,1,obj.binnumber)'};
            else
                xo = {linspace(-1,1,obj.binnumber(1))'...
                      linspace(-1,1,obj.binnumber(2))'};
            end
        end %get_bincenters_normalized

        function xo = get_bincenters(obj,DS,dim)
           %Non normalized version
           rep=size(DS,length(dim)+1)-1;
           xmin=0; xmax=0;vmin=0;vmax=0;
            for r=1:rep
                if length(dim)==1 && ~isempty(DS{dim,r})
                    xmin = min([min(DS{dim,r}.x),xmin]);
                    xmax = max([max(DS{dim,r}.x),xmax]);
                    vmin = min([min(DS{dim,r}.v),vmin]);
                    vmax = max([max(DS{dim,r}.v),vmax]);
                elseif strcmp(obj.hand,'L') && ~isempty(DS{dim(1),dim(2),r})
                    xmin = min([min(DS{dim(1),dim(2),r}.Lx),xmin]);
                    xmax = max([max(DS{dim(1),dim(2),r}.Lx),xmax]);
                    vmin = min([min(DS{dim(1),dim(2),r}.Lv),vmin]);
                    vmax = max([max(DS{dim(1),dim(2),r}.Lv),vmax]);
                elseif strcmp(obj.hand,'R') && ~isempty(DS{dim(1),dim(2),r})
                    xmin = min([min(DS{dim(1),dim(2),r}.Rx),xmin]);
                    xmax = max([max(DS{dim(1),dim(2),r}.Rx),xmax]);
                    vmin = min([min(DS{dim(1),dim(2),r}.Rv),vmin]);
                    vmax = max([max(DS{dim(1),dim(2),r}.Rv),vmax]);
                end
            end
            if length(obj.binnumber) == 1
                xo = {linspace(xmin,xmax,obj.binnumber)'...
                      linspace(vmin,vmax,obj.binnumber)'};
            else
                xo = {linspace(xmin,xmax,obj.binnumber(1))'...
                      linspace(vmin,vmax,obj.binnumber(2))'};
            end
        end %get_bincenters
        
        function plot(obj,figname)
            if nargin<2, figname=''; end
                        
            fig=figure();
            subplot(1,3,1);
            %plot(tr.xnorm,tr.vnorm,'color',[1,.7,1]);        
            %hold on; 
            i=isfinite(obj.vectors{1}) & isfinite(obj.vectors{2});
            [X,Y]=meshgrid(obj.vectors{end}{1},obj.vectors{end}{2});
            quiver(X(i),Y(i),obj.vectors{1}(i),obj.vectors{2}(i));
            %hold off;
            axis tight;
            subplot(1,3,2);
            imagesc(flipud(obj.angles{1}),[0,pi]);
            subplot(1,3,3);
            imagesc(flipud(obj.angles{2}),[0,pi]);
            
            if ~isempty(figname)
                hgsave(fig,figname); close fig;
            end
        end % plot
   end % methods
   
   methods(Static)
       function angleMax = get_maxAngle(a)
           c = floor((size(a)+1)/2);
           ac = a(c(1),c(2));
           angleMax=NaN;
           if isnan(ac), return; end
           for i=1:size(a,1)
               for j=1:size(a,2)
                   if isnan(a(i,j)), continue; end
                   atmp = abs(ac-a(i,j));
                   if atmp > pi
                       atmp = 2*pi-atmp;
                   end
                   if atmp > angleMax || isnan(angleMax)
                       angleMax=atmp;
                   end
               end
           end
       end % get_maxAngle
       
       function b = eval_neighbours(a,nhood,fun,params)
           %Applies a funtion iterativelity to an input matrix taking
           %a certain neighbourhood for each point. Boundaries are not
           %handled in a general way, only good for present use (repeting values).
           
           if nargin<4, params = cell(0,0); end
           
           [ma,na] = size(a);
           b = zeros([ma,na]);
           
           for i=1:ma,
               for j=1:na,
                   rows=i-floor((nhood(1)-1)/2):i+floor((nhood(1)-1)/2);
                   cols=j-floor((nhood(2)-1)/2):j+floor((nhood(2)-1)/2);
                   cols(cols<1)=1; cols(cols>na)=na;
                   rows(rows<1)=1; rows(rows>ma)=ma;
                   b(i,j) = feval(fun,a(rows,cols),params{:});
               end
           end
       end % eval_neighbours       
   end %methods(Static)
end% classdef
